<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tijolômetro</title>
<style>
:root{
  /* Cores base */
  --grout:#EFE6DF;
  --grid:#CDBFB3;
  --brick-bg-color: #a35a41; /* Cor dos tijolos de fundo (áreas vazadas) */

  /* Layout */
  --bg:#FFFAF5;
  --pad:0px;
  --joint:1.2px;
  --panel-max-width: 1600px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial;
  background:var(--bg); color:#111; display:flex; align-items:center; justify-content:center; padding:12px;
}
.panel{
  width:min(var(--panel-max-width), 98vw);
  background:#fff; border-radius:20px; box-shadow:0 8px 30px rgba(0,0,0,.08);
  padding:16px; display: flex; flex-direction: column; gap: 16px;
}
.gauge{
  position:relative; width:100%;
  aspect-ratio: 2 / 1;
  border-radius:14px; overflow:hidden; background:#F7EFE7;
}

/* --- NOVAS CAMADAS --- */
/* 1. Imagem "Fantasma" de Fundo (para meta visual) */
.ghost-logo{
  position:absolute; inset:var(--pad);
  width:calc(100% - (var(--pad) * 2)); height:calc(100% - (var(--pad) * 2));
  margin:auto;
  object-fit:contain;
  opacity:0.12;
  filter: grayscale(1) sepia(1) brightness(1.5);
}

/* 2. Camada de Fundo de Tijolos (preenche tudo) */
.bricks-bg{
  position:absolute; inset:0;
}

/* 3. Camada da Frente (logo colorido com máscara) */
.mask-layer{
  position:absolute; inset:0;
  background:transparent; /* Precisa ser transparente para ver o fundo */
  --mask:url('logo.png');
  -webkit-mask-image:var(--mask);   mask-image:var(--mask);
  -webkit-mask-repeat:no-repeat;    mask-repeat:no-repeat;
  -webkit-mask-position:center;     mask-position:center;
  -webkit-mask-size:contain;        mask-size:contain;
}
/* --- FIM DAS NOVAS CAMADAS --- */

.bricks{ position:relative; width:100%; height:100% }
.brick{
  position:absolute; background:var(--grout); border-radius:2px; overflow:hidden;
  box-shadow: inset 0 0 0 var(--joint) var(--grid);
}
.brick .fill{
  position:absolute; inset:0; width:0%; height:100%;
  background:var(--brick-bg-color);
  transition:width .35s ease;
}
.brick.filled .fill{ width:100% }

.hud{
  display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-around;
  gap: 10px 20px; padding: 10px; border: 1px solid #eee; border-radius: 12px;
  background: #fdfdfd; font-variant-numeric: tabular-nums;
}
.hud b{ font-size:20px }
.hud .pct{ font-weight:700 }
.hud > div { text-align: center; }

.alert{
  position:absolute; left:14px; top:14px; background:#fff3cd; border:1px solid #ffe69c; color:#664d03;
  padding:8px 10px; border-radius:10px; font-size:12px; display:none
}
.alert b{ display:block; margin-bottom:4px }
</style>
</head>
<body>
  <div class="panel">
    <div class="gauge" id="gauge">
      <div class="alert" id="logoAlert"><b>Logo não carregou</b> — coloque <code>logo.png</code> na mesma pasta.</div>

      <img src="logo.png" class="ghost-logo" id="ghostLogo" />

      <div class="bricks-bg" id="bricksBg"></div>

      <div class="mask-layer">
        <div class="bricks" id="bricksFg"></div>
      </div>
    </div>

    <div class="hud" id="hud">
      <div><span>Arrecadado</span><br><b id="hudRaised">R$ 0,00</b></div>
      <div><span>Meta</span><br><b id="hudGoal">R$ 0,00</b></div>
      <div><span>Progresso</span><br><span class="pct" id="hudPct">0%</span></div>
      <div style="font-size:11px;color:#777" id="hudUpdated">—</div>
    </div>
  </div>

<script>
(function(){
  const qs = new URLSearchParams(location.search);
  const CONFIG = {
    sheetId:  qs.get('sheet_id') || '1ZL3CcoMDVdQE8ooRX9L5QFqX1Rc70L9uguDxcmTJqGY',
    sheetName:qs.get('sheet')    || 'Tijolometro',
    range:    qs.get('range')    || 'A1:B2',
    goalField:  qs.get('goal_field')   || 'meta',
    raisedField:qs.get('raised_field') || 'arrecadado',
    logo: qs.get('logo') || 'logo.png',
    cols: parseInt(qs.get('cols') || '80', 10),
    rows: parseInt(qs.get('rows') || '48',  10),
    gap: 1,
    pollMs: parseInt(qs.get('poll_ms') || '30000', 10),
    pad: qs.get('pad') != null ? parseInt(qs.get('pad'),10) : 0,
  };

  if (!Number.isNaN(CONFIG.pad)) {
    document.documentElement.style.setProperty('--pad', CONFIG.pad + 'px');
  }
  document.querySelector('.mask-layer').style.setProperty('--mask', `url('${CONFIG.logo}')`);
  document.getElementById('ghostLogo').src = CONFIG.logo;

  const gauge = document.getElementById('gauge');
  const bricksFgEl = document.getElementById('bricksFg');
  const bricksBgEl = document.getElementById('bricksBg');
  const hud = {
    raised: document.getElementById('hudRaised'),
    goal: document.getElementById('hudGoal'),
    pct: document.getElementById('hudPct'),
    updated: document.getElementById('hudUpdated')
  };
  const alertBox = document.getElementById('logoAlert');

  const paintCanvas = document.createElement('canvas');
  const pctx = paintCanvas.getContext('2d', { willReadFrequently:true });
  let logoImg = null, aspectSet = false;
  let bricksFg = [], bricksBg = [];
  let lastProgress = 0;

  function formatBRL(n){ /* ... (código sem alterações) ... */ return new Intl.NumberFormat('pt-BR',{style:'currency',currency:'BRL'}).format(n); }
  function debounce(fn,ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
  
  function loadLogo(src){
    return new Promise(res=>{
      const im = new Image();
      im.onload = ()=>{ logoImg = im; alertBox.style.display='none'; res(true); };
      im.onerror = ()=>{ alertBox.style.display='block'; res(false); };
      im.src = src + '?t=' + Date.now();
    });
  }

  function ensureAspectFromLogo(){
    if(aspectSet || !logoImg) return;
    const ar = logoImg.naturalWidth / logoImg.naturalHeight;
    if(ar > 0) gauge.style.aspectRatio = `${ar} / 1`;
    aspectSet = true;
  }
  
  // NOVA FUNÇÃO: Calcula a cor média de uma área no canvas para evitar "cores erradas"
  function getAverageColor(x, y, w, h) {
    const imgData = pctx.getImageData(x, y, w, h).data;
    let r = 0, g = 0, b = 0, count = 0;
    for (let i = 0; i < imgData.length; i += 4) {
      const alpha = imgData[i + 3];
      if (alpha > 128) { // Só considera pixels com mais de 50% de opacidade
        r += imgData[i];
        g += imgData[i + 1];
        b += imgData[i + 2];
        count++;
      }
    }
    if (count < (w*h)/4) return null; // Se menos de 25% da área do tijolo tem cor, considera transparente
    return `rgb(${Math.round(r/count)}, ${Math.round(g/count)}, ${Math.round(b/count)})`;
  }

  function colorizeBricks(){
    if(!logoImg) return;
    const W = bricksFgEl.clientWidth, H = bricksFgEl.clientHeight;
    if(!W || !H) return;

    paintCanvas.width = W; paintCanvas.height = H;
    pctx.clearRect(0,0,W,H);
    const ar = logoImg.naturalWidth / logoImg.naturalHeight;
    let dw = W, dh = W/ar;
    if(dh > H){ dh = H; dw = H*ar; }
    const dx = (W - dw)/2, dy = (H - dh)/2;
    pctx.drawImage(logoImg, dx, dy, dw, dh);

    for(let i = 0; i < bricksFg.length; i++){
      const bFg = bricksFg[i];
      const bBg = bricksBg[i];
      
      const color = getAverageColor(bFg._x, bFg._y, bFg._w, bFg._h);
      
      const fgFill = bFg.querySelector('.fill');
      const bgFill = bBg.querySelector('.fill');
      
      if(color){
        fgFill.style.background = color;
        bgFill.style.opacity = '0'; // Esconde tijolo do fundo se há cor na frente
      } else {
        fgFill.style.background = 'transparent'; // Deixa tijolo da frente transparente
        bgFill.style.opacity = '1'; // Mostra tijolo do fundo
      }
    }
  }

  // ATUALIZADA: Cria e posiciona os tijolos nas DUAS camadas
  function layoutBricks(){
    ensureAspectFromLogo();
    const W = bricksFgEl.clientWidth, H = bricksFgEl.clientHeight;
    if(!W || !H) return;

    const { gap, cols, rows } = CONFIG;
    const brickW = Math.floor((W - gap*2) / cols) - gap;
    const brickH = Math.floor((H - gap*2) / rows) - gap;

    const target = rows * cols;
    if(bricksFg.length !== target){
      bricksFgEl.innerHTML = ''; bricksBgEl.innerHTML = '';
      bricksFg = []; bricksBg = [];
      const fragFg = document.createDocumentFragment();
      const fragBg = document.createDocumentFragment();
      for(let i=0;i<target;i++){
        const elF = document.createElement('div'); elF.className='brick';
        const fillF = document.createElement('div'); fillF.className='fill'; elF.appendChild(fillF);
        fragFg.appendChild(elF); bricksFg.push(elF);
        
        const elB = document.createElement('div'); elB.className='brick';
        const fillB = document.createElement('div'); fillB.className='fill'; elB.appendChild(fillB);
        fragBg.appendChild(elB); bricksBg.push(elB);
      }
      bricksFgEl.appendChild(fragFg);
      bricksBgEl.appendChild(fragBg);
    }

    let idx = 0;
    for(let r=0;r<rows;r++){
      const offset = (r%2===1) ? Math.floor(brickW/2) : 0;
      for(let c=0;c<cols;c++){
        const x = gap + c*(brickW+gap) + offset;
        const y = gap + r*(brickH+gap);
        
        const bFg = bricksFg[idx];
        bFg.style.cssText = `left:${x}px; top:${y}px; width:${brickW}px; height:${brickH}px;`;
        bFg._x = x; bFg._y = y; bFg._w = brickW; bFg._h = brickH;

        const bBg = bricksBg[idx];
        bBg.style.cssText = `left:${x}px; top:${y}px; width:${brickW}px; height:${brickH}px;`;
        idx++;
      }
    }

    colorizeBricks();
    applyProgress(lastProgress);
  }

  function buildOrder(){
    const { rows, cols } = CONFIG;
    const orderedFg=[], orderedBg=[];
    for(let r=rows-1; r>=0; r--){
      for(let c=0; c<cols; c++){
        const idx = r * cols + c;
        orderedFg.push(bricksFg[idx]);
        orderedBg.push(bricksBg[idx]);
      }
    }
    return [orderedFg, orderedBg];
  }

  // ATUALIZADA: Aplica o progresso nas DUAS camadas
  function applyProgress(p){
    p = Math.max(0, Math.min(1, p||0)); lastProgress = p;
    const [orderFg, orderBg] = buildOrder();
    const total = orderFg.length;
    const filled = Math.floor(p*total);
    const frac   = (p*total) - filled;

    for(let i=0; i < total; i++){
      const bFg = orderFg[i], bBg = orderBg[i];
      const fillFg = bFg.querySelector('.fill'), fillBg = bBg.querySelector('.fill');
      
      bFg.classList.remove('filled','partial'); fillFg.style.width='0%';
      bBg.classList.remove('filled','partial'); fillBg.style.width='0%';

      if(i < filled){
        bFg.classList.add('filled'); fillFg.style.width='100%';
        bBg.classList.add('filled'); fillBg.style.width='100%';
      }
    }
    
    if(filled < total){
      const bFg = orderFg[filled], bBg = orderBg[filled];
      const fillFg = bFg.querySelector('.fill'), fillBg = bBg.querySelector('.fill');
      const percent = Math.round(frac*100)+'%';
      bFg.classList.add('partial'); fillFg.style.width = percent;
      bBg.classList.add('partial'); fillBg.style.width = percent;
    }
  }

  async function fetchProgress(){
    /* ... (código sem alterações, apenas o formato da data no final) ... */
    const base = `https://docs.google.com/spreadsheets/d/${CONFIG.sheetId}/gviz/tq`;
    const params = new URLSearchParams({ tqx:'out:json', sheet:CONFIG.sheetName, range:CONFIG.range, t:Date.now()+'' });
    try{
      const res = await fetch(`${base}?${params}`, { cache:'no-store' });
      const txt = await res.text();
      const m = txt.match(/google\.visualization\.Query\.setResponse\((.*)\);/s);
      const data = JSON.parse(m[1]);
      const rows = data.table.rows || [];
      const kv = {};
      rows.forEach(r=>{
        const k = r.c?.[0]?.v?.toString().trim().toLowerCase();
        const vRaw = r.c?.[1]?.v;
        const v = typeof vRaw==='string' ? parseFloat(vRaw.replace(/\./g,'').replace(',','.')) : vRaw;
        if(k) kv[k] = Number(v||0);
      });
      const goal   = Number(kv[CONFIG.goalField]   || 0);
      const raised = Number(kv[CONFIG.raisedField] || 0);
      const p = goal>0 ? (raised/goal) : 0;

      applyProgress(p);
      hud.raised.textContent = formatBRL(raised);
      hud.goal.textContent   = formatBRL(goal);
      hud.pct.textContent    = Math.max(0,Math.min(100,p*100)).toFixed(1).replace('.',',') + '%';
      hud.updated.textContent= 'Atualizado: ' + new Date().toLocaleString('pt-BR', {dateStyle:'short', timeStyle:'short'});
    }catch(e){
      console.error(e);
      if(hud.updated.textContent==='—'){ hud.updated.textContent='(aguardando planilha)'; }
    }
  }

  window.addEventListener('resize', debounce(()=>{ layoutBricks(); }, 120));
  loadLogo(CONFIG.logo).then(()=>{ ensureAspectFromLogo(); layoutBricks(); });
  fetchProgress();
  setInterval(fetchProgress, CONFIG.pollMs);
})();
</script>
</body>
</html>